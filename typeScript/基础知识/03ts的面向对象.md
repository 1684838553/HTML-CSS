1. object对象类型

   ```typescript
   let person: {
     name: string,
     age: number,
     nickName:string
   } = {
     name: 'tom',
     age: 23,
     nickName:'jack'
   } 
   
   console.log(person.nickName)  //如果调用对象中未定义的类型，会报错；但如果对象定义为any类型，就不会报错
   ```

2. interface接口和class类

   类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以

   类是一个特殊的函数

   访问修饰符 public private protected

   public 在外部可以访问类中的变量 变量不加访问修饰符，默认是public
   private 外部不能访问

   ```typescript
   interface Point{
     x: number
     y:number
   }
   let drawPoint = (point:Point) => {
     console.log({x:point.x,y:point.y})
   }
   
   //两点对象之间的距离
   let getDistance = (a: Point, b: Point) => {
     //...
   }
   ```

   ```typescript
   interface IPoint{
     x: number
     y: number
     drawPoint: () => void
     getDistance:(p:IPoint)=>number
   }
   
   
   class Point implements IPoint{
     // 使用访问修饰符
     constructor(public x: number,public y: number) {
       // this.x = x
       // this.y = y
     }
   
     drawPoint = () => {
       console.log(this.x,this.y)
     }
     getDistance = (p:IPoint) => {
       return Math.pow(p.x-this.x,2)+Math.pow(p.y-this.y,2)
     }
   
     setX = (value:number) => {
       if (value < 0) {
          throw new Error('x不能小于0')
       }
       this.x = value
     }
     getX = ()=>{
       return this.x
     }
   }
   
   const point = new Point(12,23)
   point.drawPoint()
   
   //public private protected
   
   // public 在外部可以访问类中的变量 变量不加访问修饰符，默认是public
   // private 外部不能访问
   ```

3. Module模块

   模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。

   ```typescript
   //导出
   export const numberRegexp = /^[0-9]+$/;
   
   export class ZipCodeValidator implements StringValidator {
       isAcceptable(s: string) {
           return s.length === 5 && numberRegexp.test(s);
       }
   }
   
   //导入
   import { numberRegexp,ZipCodeValidator } from "./ZipCodeValidator";
   
   ```

4. 泛型

   ```typescript
   let list:Array<string> = ['1']
   
   //确保类型的一致性
   function identity<T>(arg: T): T {
       return arg;
   }
   //给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。
   
   //处理多个泛型类型
   let make = <T,Y>(x:T,y:Y)=>[x,y]
   ```

   

