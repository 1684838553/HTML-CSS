## vue 和 react 的异同点

1. 都使用虚拟 dom
2. 组件化开发
3. 单向数据流
4. 都支持服务端渲染

都是要虚拟 DOM，都是单项数据流，都是组件化开发，都可以服务端渲染

5. 生态圈 react 是 redux,vue 是 vuex
6. vue 是双向绑定 react 单向绑定
7. react 使用 jsx vue 使用 template
8. react 手动 setState,vue 自动（初始化已响应式处理）

vue vuex 自动处理状态 双向绑定 template
react redux 手动处理状态 单向绑定 jsx

## vue 的优缺点

响应式，渐进式，轻量级，虚拟 DOM，单页面路由，数据与视图分开
不利于 seo,不支持 ie8 以下，首屏加载时间长

## 实现一个水平垂直居中

## margin 塌陷？有没有遇到过其他 css 问题？

1. margin 塌陷不是 css 的 bug，而是设计如此，为了页面更加美观，不然，中间的元素之间的 margin 是首尾两个的两倍

2. 与 margin 塌陷有关的是 bfc
   bfc 是页面的一块渲染区域，不是 css 样式
3. 什么是 bfc
   有浮动元素，绝对定位元素，非块级盒子的块级容器以及 overflow 不为 visible 的块级盒子，会为他们的内容创建新的 bfc
4. 怎么形成 bfc
   - 根元素
   - float 值不为 none
   - position 的值为 absolute 或 fixed
   - overflow 不为 visible
   - display 的值为 flex,inline-block,inline-cell,inline-flex
5. bfc 特性

   - bfc 是页面上的一个独立容器，不受外界干扰或干扰外界
   - 计算 bfc 高度时，浮动元素也参与计算
   - bfc 区域不会与 float 的元素区域重叠
   - bfc 元素会在垂直方向上放置
   - 两个相邻元素的 margin 会发生重叠

6. 解决 margin 塌陷 margin 重叠 兄弟元素 margin 塌陷 父子元素（使用 bfc 解决 margin 塌陷问题）
   - 给父盒子添加 border
   - 给父盒子添加 padding-top
   - 给父盒子添加 overflow:hidden
   - 父盒子:position:fixed
   - 父盒子:display:table
   - 给子元素的前面添加一个兄弟元素

## vue 响应式原理

原理：数据劫持+响应式原理
对象通过 Object.defineProperty 将属性进行劫持（已有属性），数组进行方法重写

## 为什么只对对象劫持，而要对数组进行方法重写？

因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案

## 组件 data 为什么是一个函数？

data 之所以是一个函数，是因为一个组件可能会被多次调用，每次吊椅，执行 data()函数返回一个新的对象，可以避免多次调用之间的数据污染

## vue Object.defineProperty 缺陷？数组 7 个方法怎么重写的？

1.  无法监听数组变化
2.  只能劫持对象的属性而不是劫持整个对象，我们需要对对象进行遍历

## 子组件修改 props 的数据

1. 修改基本数据类型，报错
2. 修改引用类型 重新赋值，会报错；修改某个属性值，不报错，并且父组件数据也会修改

## 虚拟 dom

1. 本质：虚拟 dom 是 js 对象，里面包含 props,tag,children 等属性
2. 存在的意义

   - 相当于在 js 和真实 dom 之间加了一个缓存，利用 diff 算法，避免了无用的 dom 操作
   - 实现了跨平台，而不只是浏览器中的 DOM

3. 特点
   - 将 html 转化为虚拟 DOM
   - 虚拟 dom 不一定更快

## diff 算法

1. 原理

   - 对比新老节点，将变化的部分更新到视图上。对应到代码上，就是一个 diff 函数，返回一个补丁
   - 先序深度优先

   diff 算法会在同一层级之间通过 key 值比较

   - tree diff 同层级比较，key 值相同，在比较子节点
   - component diff 判断组件类型是否相同，如果相同，继续往下比较，不同，则用新节点替换纠结点
   - element diff 新节点不在旧 DOM 树中，插入；新节点中没有旧节点，删除旧结点；移动操作

## 从输入 URL 到页面展示，这中间发生了什么

1.  输入 url
2.  构建请求
3.  查找缓存，浏览器通过响应头中是否有 cache-Control 字段，判断缓存是否存在；如果存在，将缓存返给浏览器；如果不存在或缓存过期，继续下一步
4.  域名解析，获取 ip 和端口
5.  等待 tcp 队列，谷歌浏览器相同域名下，最多建立 6 个请求，超过 6 个，进入队列等待
6.  建立 tcp 链接 **三次握手**
7.  发送 http 请求
8.  服务器处理请求
9.  服务器返回请求，返回 301 或 302，301 是永久重定向，302 是暂时重定向；浏览器重定向在另一个网址，在 location 中获取；返回 304，告诉浏览器数据没有修改，可以在浏览器缓存中获取；返回 200，继续请求
10. 判断请求中是否有 keep-alive 字段，有该字段，tcp 保持链接；没有该字段，断开链接，四次挥手

## 三次握手

1. 客户端发包，服务端接受 服务端确定客户端的发送能力和服务端的接受能力没有问题
2. 服务端发包，客户端接受 客户端确定，客户端和服务端的收发能力没有问题
3. 客户端发包，服务端接受 服务端确定，客户端和服务端的收发能力没有问题

第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SENT 状态。
首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。

第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。
在确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y。

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。

## 四次挥手

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，"你发的 FIN 报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。
第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。
第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。
第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

## eslint

大数相加: 给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。leetcode 415. 字符串相加
写一个事件 Event 类，实现 on，off，emit，once 功能，同时 on 要支持 debounce。eg：on('click',function(){},500)
介绍下让自己成长最大的项目？
你觉得现在遇到的最难的问题是什么？
为什么要做微前端？
回到写的第二道题，说到了 setTimeout 设定的时间，函数能准确按时执行吗？setTimeout 怎么能做到准时？
js 是单线程还是多线程？为什么？支不支持多线程？支持多线程的方式有哪些？node 端多线程知不知道？进程和线程的区别？进程内存计算机如何分配？线程资源如何分配？
跨域的解决方案
如何实现移动端 1px 边框
什么是 html 可替换元素？
一个图片对应多个 cdn 地址，如果第一个地址不能用了，需要换成下一个，怎么做？
vue 生命周期详细描述下？改变组件 data 里面的东西会触发什么生命周期？
vue2.x 响应式原理？Object.defineProperty 的一些参数？
for in 可以遍历出来那些东西？for in 可以遍历数组吗？可以遍历出那些东西？
vue 组件 scoped 作用？实现原理？其他的 css 隔离方案？

## 页面结构语义化

1. 易修改，易维护
2. 无障碍阅读支持
3. 搜索引擎友好
4. 面向未来的 HTML，浏览器在未来提供更丰富的支持

语义元素均有一个共同特点——他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。

header
main
footer
aside
nav
section
article
...

## localstorage,seesionStorage,cookie

## post，get 的区别

## 怎么用 ES5 去实现 ES6 类的继承？

## http1.1 和 http2 的区别？http1.1 中做了哪些项目优化？http1.1 中用的哪些优化手段，会在 http2 中失效？http2.0 还存在什么问题？http3 了解吗

## vue keep-alive 原理？

keep-alive 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

## 为什么使用 key 能提升 diff 性能

Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。

key 是用来识别 dom 元素的唯一标识。如果增加删除列表中数据，使用 index 作为索引，操作的都没元素与之前的可能不一样

diff 使用 key 值来判断是否是同一个组件，所以，如果 key 值不唯一且固定，会消耗很多性能

## this 指向的理解？声明时和运行时指向？箭头函数指向？修改 this 指向？

1. 在全局上下文中，this 指向 window
2. 在函数上下文中，this 指向调用函数的对象
3. call,apply,bind 中，this 指向绑定的对象
4. 在构造函数中，this 指向正在创建的新对象
5. 在 dom 对象中，this 指向触发事件的元素；在 ie 中，attachEvent 中 this 指向 window
6. 在箭头函数中，所有函数都没有自己的 this,指向外层

## new 一个对象时，发生了什么

1. 创建一个空对象
2. 将 this 指向该对象
3. 创建自己的属性和方法
4. 返回 this

## call,apply,bind 区别？讲一下实现一个 bind 的思路

1. 三者都能改变 this 的指向
2. call,bind 的第二个参数是参数列表，apply 的第二个参数是参数数组
3. bind 创建了一个新的函数

## 函数柯里化概念，常用场景？

## 关于缓存的一些东西？如何提高缓存命中率？

## 数组和链表在计算机中存储的方式？计算机中增加一个数组元素的方式？

## 如何封装一个组件
