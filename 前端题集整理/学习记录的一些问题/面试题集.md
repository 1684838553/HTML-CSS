## css用到的一些单位
- px 表示像素
- rem rem，相对单位，相对的只是HTML根元素font-size的值

特点：
rem单位可谓集相对大小和绝对大小的优点于一身
和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸

- em  em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）

特点：
em 的值并不是固定的
em 会继承父级元素的字体大小
em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸
任意浏览器的默认字体高都是 16px

- vw 
- vh 
- %

## vue 样式scoped怎么实现局部样式的

'data-v-xxx'标记是vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的'data-v-xxx'标记

## 团队开发时，怎么解决类名冲突问题

- 私有作用域前缀
    通常我们写一些希望被别人复用的第三方组件的时候会采用，私有作用域前缀的方案。

- css-module

- 不命名
    1. css in js
    2. tailwind / function css / unit css 
    3. Atomic css

## 块级元素和内联元素

1. 块级元素
    - div
    - p
    - ul
    - li
    - ol
    - h1~h6

2. 内联元素
    - img
    - input
    - span
    - a
    - label
    - button

## 点击事件中，terget和current target的区别

Event.target 对触发事件的对象的引用(即它标识事件发生的元素)

event.currentTarget 当事件遍历DOM时，标识事件的当前目标。它总是引用事件处理程序附加到的元素

target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的，
而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。

## js基本数据类型

- number
- string
- null
- boolean
- undefined
- symbol

## 怎么判断Array和object

1.  Array.isArray()
2. obj instanceof Array
3. Object.prototype.toString.call()
4. Array.prototype.isPrototypeOf(obj)

## 类型转换

1. 1+null = 1  Number(null) === 0
2. 1+undefined = NaN Number(undefined) === NaN

## class

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。
class 的本质是 function。
它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。
constructor 方法是类的默认方法，创建类的实例化对象时被调用。
super()指向父类
class 的实例化必须通过 new 关键字创建。

## vue和react的ref有什么区别

vue 的 ref 属性主要用于访问子组件（vue组件）或者子元素（dom元素），
具体写法：<base-input ref="usernameInput"></base-input>
获取实例：this.$refs.usernameInput

react class组件
通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。

react 函数组件 React.forwardRef 接受一个渲染函数
const ref = useRef()

## 判断一个空对象

1. 最常见的思路，for...in... 遍历属性，为真则为“非空数组”；否则为“空数组”

```javascript
for (var i in obj) { // 如果不为空，则会执行到这一步，返回true
    return true
}
return false // 如果为空,返回false
```

2. 通过 JSON 自带的 stringify() 方法来判断:

JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。

```javascript
if (JSON.stringify(data) === '{}') {
    return false // 如果为空,返回false
}
return true // 如果不为空，则会执行到这一步，返回true
```
这里需要注意为什么不用 toString()，因为它返回的不是我们需要的。

```javascript
var a = {}
a.toString() // "[object Object]"
```

3. ES6 新增的方法 Object.keys():

Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组。

如果我们的对象为空，他会返回一个空数组，如下：
```javascript
var a = {}
Object.keys(a) // []
```
我们可以依靠Object.keys()这个方法通过判断它的长度来知道它是否为空。
```javascript
if (Object.keys(object).length === 0) {
    return false // 如果为空,返回false
}
return true // 如果不为空，则会执行到这一步，返回true
```
## 两个对象数组，合并属性并去重

## vue的diff算法

## 数组遍历的五种方法，map和forEach的区别，怎么实现使用forEach一个filter,可以中断循环

- forEach
- map
- some
- every
- filter

forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

for()  传一个回调函数判断是否可以中断循环


##  es6常用的一些特性

const let ... 解构 函数参数解构，默认值，name,length
...

## 普通函数和箭头函数的区别

1. 普通函数使用function来定义函数，箭头函数使用=>来定义
2. 箭头函数的this指向外层，即定义是所在作用域的this，而不是调用时所在作用域的this
3. 箭头函数不能作为构造函数使用
4. 箭头函数没有arguments对象

## promise解决什么问题

1. 回调地狱问题，回调函数层层嵌套
2. 代码的可读性问题，promise可以链式调用

## react和vue父子之间传值的一个全局对比

