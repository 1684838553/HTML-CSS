## 12 | 栈空间和堆空间：数据是如何存储的？

1. js 是什么类型的语言
   动态语言：把在运行过程中需要检查数据类型的语言称为动态语言
   弱类型语言：支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言
   `弱类型语言`，不用定义变量的数据类型，JavaScript 引擎能计算出来
   `动态语言`，同一变量，可以保存不同类型的数据

   ```javascript
   var bar; //undefined
   bar = 12; //number
   bar = "极客时间"; //string
   bar = true; // boolean
   bar = null; // object
   bar = { name: "极客时间" }; // object
   ```

2. JavaScript 数据类型
   Boolean Null Undefined Number String Symbol `BigInt` Object

   - 使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。

   - Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型

   - 前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型

3. 内存空间

   - 代码空间：存储可执行代码
   - 栈空间：即调用栈，一般空间不大，存储执行上下文，基本数据类型的值
   - 堆空间：一般空间很大，存放引用类型的值

   **为什么引用类型不能直接放在栈中？**

   <font color="red">因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率</font>

   在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。**

4. 再谈闭包

   ```javascript
   
   function foo() {
       var myName = "极客时间"
       let test1 = 1
       const test2 = 2
       var innerBar = { 
           setName:function(newName){
               myName = newName
           },
           getName:function(){
               console.log(test1)
               return myName
           }
       }
       return innerBar
   }
   var bar = foo()
   bar.setName("极客邦")
   bar.getName()
   console.log(bar.getName())
   
   //1、当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
   //2、在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
   //3、接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
   //4、由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中
   ```

   

