## 08 | 调用栈：为什么 JavaScript 代码会出现栈溢出？

### 哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文?

1. **全局作用域**当 js 执行全局代码时，会编译全局代码并创建全局执行上下文，在整个页面生存周期内，全局执行上下文只一份
2. **函数作用域**调用函数时，会编译并创建函数执行上下文，执行结束后，会被销毁（使用 eval 函数时，eval 代码会被编译，并创建执行上下文）

### 调用栈

调用栈就是用来管理函数调用关系的一种数据结构

1. 函数调用
  函数调用就是运行一个函数

  ```javascript
  var a = 2
  function add(){
  var b = 10
  return  a+b
  }
  add()
  
  //全局执行上下文
  //变量环境 a = undefined
  add = function(){
  var b = 10
  return  a+b
  }
  
  //执行上下文准备好之后,开始执行全局代码
  //add函数编译时，会创建函数执行上下文和可执行代码
  
  ```

2. 什么是JavaScript调用栈

   **在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？**

   通过栈来管理（栈：先进后出）

   <font color="red">JavaScript 引擎会将执行上下文压入栈中，这种栈称为执行上下文栈，又称调用栈</font>

   调用栈是 JavaScript 引擎追踪函数执行的一个机制

### 开发时，如何利用好调用栈

1. 如何利用浏览器查看调用栈的信息
   - 你可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在需要查看的地方加上断点，并刷新页面，在右边“call stack”查看当前调用栈的情况
   - 可以使用 console.trace() 来输出当前的函数调用关系

2. 栈溢出

   **调用栈是有大小的**，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。

   **调用栈有两个指标，最大栈容量和最大调用深度，满足其中任意一个就会栈溢出**

   ```javascript
   function division(a,b){
       return division(a,b)
   }
   console.log(division(1,2))
   //抛出错误：超过了最大栈调用大小（Maximum call stack size exceeded）
   ```

   **那为什么会出现这个问题呢？**

   因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。

   可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。

**思考题：这是一段递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？**

```javascript
function runStack (n) {
  if (n === 0) return 100;
  return runStack( n- 2);
}
runStack(50000)
//尝试一下尾递归和尾优化
//循环
function runStack(n) {
    while (true) {
        if (n === 0) {
            return 100;
        }
        if (n === 1) { // 防止陷入死循环
            return 200;
        }
        n = n - 2;
    }
}
console.log(runStack(50000));
```

`总结`

1、每调用一个函数，都会创建执行上下文，并将其压入调用栈，然后开始执行函数代码

2、如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。(在A中调用B,在B中调用C,三者在同一个栈中，等三个函数都执行完，执行上下文才会被弹出栈)

3、当前函数执行完后，该函数执行上下文将会弹出调用栈

4、当分配的调用栈空间被沾满时，会引发**堆栈溢出**问题
