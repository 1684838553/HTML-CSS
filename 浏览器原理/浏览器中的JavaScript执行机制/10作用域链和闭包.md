## 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？

1. 作用域链

   在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文;如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 外部引用所指向的执行上下文中查找

2. 词法作用域

   词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是`静态的作用域`，通过它就能够预测代码在执行过程中如何查找标识符。

   **词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

3. 在块级作用域中的变量查找

   ```javascript
   
   function bar() {
       var myName = "极客世界"
       let test1 = 100
       if (1) {
           let myName = "Chrome浏览器"  //let , const 定义的变量放在词法环境
           console.log(test)
       }
   }
   function foo() {
       var myName = "极客邦"
       let test = 2
       {
           let test = 3
           bar()
       }
   }
   var myName = "极客时间"
   let myAge = 10
   let test = 1
   foo()  //1
   //ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。
   //首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。
   ```

   查找过程，如图`块级作用域中是如何查找变量的.png`

4. 闭包

   **在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。**比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

   ```javascript
   
   function foo() {
       var myName = "极客时间"
       let test1 = 1
       const test2 = 2
       var innerBar = {
           getName:function(){
               console.log(test1)
               return myName
           },
           setName:function(newName){
               myName = newName
           }
       }
       return innerBar
   }
   var bar = foo()
   bar.setName("极客邦")
   bar.getName()  // 1
   console.log(bar.getName()) // 1 极客邦
   
   //根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量
   //所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：闭包的产生过程.png
   //是专属闭包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该闭包的，我们就可以把这个背包称为 foo 函数的闭包。
   ```

   查找过程，如图`执行到 return bar 时候的调用栈.png`

5. 闭包是怎么回收的

   <font color="red">闭包使用原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</font>

   - 闭包函数是全局变量，闭包一直存在直到页面关闭；如果，这个闭包以后不再使用，会造成内存泄漏
   - 闭包函数是局部变量，函数销毁后，下次js引擎执行垃圾回收时，判断该闭包是否不在使用，该内存会被垃圾回收机制回收

**思考题：**

```javascript

var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }    
}
function foo() {
    let myName = "极客时间"
    return bar.printName
}
let myName = "极客邦"
let _printName = foo()
_printName()
bar.printName()


var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }
}
function foo() {
    let myName = " 极客时间 "
    return bar.printName
}
let myName = "极客邦"
let _printName = foo()
_printName()  // "极客邦"
bar.printName() // "极客邦"

//最终打印出来的值都是“极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。

//全局执行上下文：
变量环境：
Bar=undefined
Foo= function
词法环境：
myname = undefined
_printName = undefined

//开始执行：
bar ={myname: "time.geekbang.com", printName: function(){...}}

myName = " 极客邦 "
 _printName = foo() 调用foo函数，压执行上下文入调用栈

//foo函数执行上下文：
变量环境： 空
词法环境： myName=undefined
开始执行：
myName = " 极客时间 "
return bar.printName
开始查询变量bar， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（没有）-> 查找outer语法环境（找到了）并且返回找到的值
pop foo的执行上下文

_printName = bar.printName
printName（）压bar.printName方法的执行上下文入调用栈

//bar.printName函数执行上下文：
变量环境： 空
词法环境： 空
开始执行：
console.log(myName)
开始查询变量myName， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（找到了）
打印" 极客邦 "
pop bar.printName的执行上下文


bar.printName() 压bar.printName方法的执行上下文入调用栈

//bar.printName函数执行上下文：
变量环境： 空
词法环境： 空
开始执行：
console.log(myName)
开始查询变量myName， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（找到了）
打印" 极客邦 "
pop bar.printName的执行上下文
```

`总结`

1、通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，二词法作用域反映了代码的结构

2、在块级作用域中是如何通过作用域链来查找变量的

3、什么是闭包
